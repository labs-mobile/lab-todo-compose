Parfait ! Voici un **tutoriel complet et p√©dagogique** sur l‚Äôutilisation de **`ViewModel` dans Jetpack Compose**, destin√© √† des apprenants d√©butants ou interm√©diaires.

Ce tutoriel est structur√© comme un **article de formation**, avec :

- üß© **Introduction** : les bonnes questions √† se poser  
- üìò **Partie Th√©orique** : concepts expliqu√©s  
- üõ†Ô∏è **Partie Pratique** : un exemple minimaliste  
- ‚úÖ **R√©sum√© p√©dagogique clair**

---

# üìö Comprendre `ViewModel` dans Jetpack Compose

---

## üß© Introduction : les bonnes questions √† se poser

Quand on commence avec **Jetpack Compose**, on apprend vite √† utiliser :

```kotlin
var compteur by remember { mutableStateOf(0) }
```

Puis on d√©couvre `StateFlow`, et on se dit :

- ü§î Pourquoi ne pas utiliser **juste `StateFlow`** dans un `Composable` ?
- ü§î √Ä quoi sert **`ViewModel`** si on peut observer directement une variable ?
- ü§î Est-ce vraiment utile de cr√©er une classe en plus juste pour stocker une valeur ?

C‚Äôest ce qu‚Äôon va explorer ici.

---

## üìò Partie Th√©orique

### ‚úÖ C‚Äôest quoi un `ViewModel` ?

Un `ViewModel` est une **classe Android con√ßue pour stocker et g√©rer les donn√©es li√©es √† l‚Äôinterface utilisateur**, de mani√®re **persistante et s√©curis√©e**.

> Il fait partie de l‚Äôarchitecture officielle "MVVM" d‚ÄôAndroid.

---

### üîÅ Le cycle de vie : le vrai enjeu

| M√©thode | Cycle de vie |
|--------|------------------------------|
| `remember {}` | Se r√©initialise √† chaque recr√©ation du composable |
| `StateFlow` seul dans un composable | Recr√©e √† chaque recomposition |
| `ViewModel` | Persiste m√™me apr√®s une **rotation d‚Äô√©cran**, **navigation**, etc. |

---

### ‚ùå Pourquoi ne pas utiliser seulement `StateFlow` ?

Si tu d√©clares un `StateFlow` dans un `Composable`, comme √ßa :

```kotlin
val compteur = MutableStateFlow(0)
```

Et que tu observes :

```kotlin
val valeur by compteur.collectAsState()
```

‚û§ √áa marche‚Ä¶ **jusqu‚Äô√† la premi√®re rotation de l‚Äô√©cran** !  
Pourquoi ? Parce que l‚Äôobjet `compteur` est recr√©√© √† chaque fois, donc sa valeur repasse √† 0.

---

### ‚úÖ Pourquoi `ViewModel` est la bonne solution ?

- Il **vit plus longtemps** que le `Composable`.
- Il est **li√© au cycle de vie de l‚ÄôActivity ou du Fragment**, pas du composant UI.
- Il permet de **s√©parer clairement la logique m√©tier** de l‚Äôinterface graphique.
- Il facilite le **partage de donn√©es entre plusieurs √©crans** (navigation).

---

## üõ†Ô∏è Partie Pratique ‚Äî Exemple ultra simple

### üéØ Objectif :  
Cr√©er un compteur qui **garde sa valeur m√™me si on tourne l‚Äô√©cran**.

---

### üì¶ 1. Cr√©er le `ViewModel`

```kotlin
import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

class CompteurViewModel : ViewModel() {
    private val _compteur = MutableStateFlow(0)
    val compteur: StateFlow<Int> = _compteur

    fun incrementer() {
        _compteur.value++
    }
}
```

---

### üé® 2. UI avec Compose

```kotlin
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MonApp()
        }
    }
}

@Composable
fun MonApp(viewModel: CompteurViewModel = viewModel()) {
    val compteur by viewModel.compteur.collectAsState()

    Surface(modifier = Modifier.fillMaxSize()) {
        Column(
            modifier = Modifier.fillMaxSize(),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(text = "Compteur : $compteur", style = MaterialTheme.typography.h5)
            Spacer(modifier = Modifier.height(16.dp))
            Button(onClick = { viewModel.incrementer() }) {
                Text("Incr√©menter")
            }
        }
    }
}
```

---

## üîç Ce qu‚Äôon a appris

| √âl√©ment | R√¥le |
|--------|------|
| `ViewModel` | Contient la logique m√©tier et les donn√©es |
| `MutableStateFlow` | Permet de g√©rer une donn√©e r√©active |
| `viewModel()` | Cr√©e ou r√©cup√®re l‚Äôinstance du `ViewModel` |
| `collectAsState()` | Lie le flux √† l‚ÄôUI Compose |

---

## ‚úÖ R√©sum√© p√©dagogique

| Question | R√©ponse |
|---------|---------|
| Peut-on utiliser juste `StateFlow` ? | Non, car il est recr√©√© √† chaque recomposition. |
| Pourquoi `ViewModel` ? | Pour garder les donn√©es m√™me apr√®s une rotation d‚Äô√©cran. |
| Est-ce que c‚Äôest plus propre ? | Oui, car la logique m√©tier est s√©par√©e de l‚ÄôUI. |
