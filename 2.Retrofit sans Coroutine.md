# üìö Tuto ‚Äî Utiliser Retrofit sans Coroutine (avec Callback)

---

## üéØ Objectif p√©dagogique

> Apprendre √† utiliser **Retrofit pour faire une requ√™te HTTP GET simple**, **sans utiliser de coroutine**, mais en mode **classique avec callback** (`enqueue()`).

---

## ‚úÖ R√©sultat attendu

On va **r√©cup√©rer un ‚ÄúTodo‚Äù depuis l‚ÄôAPI** `https://jsonplaceholder.typicode.com/todos/1`  
et **afficher son titre** dans une interface Compose.

---

## üß± √âtape 1 : Pr√©parer le projet

### üì¶ Ajoute les d√©pendances dans `build.gradle (Module: app)`

```kotlin
// Retrofit
implementation 'com.squareup.retrofit2:retrofit:2.9.0'
implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
```

Clique sur **Sync Now** une fois ajout√©.

---

## üóÇÔ∏è √âtape 2 : Cr√©er le mod√®le de donn√©es

```kotlin
data class Todo(
    val id: Int,
    val title: String,
    val completed: Boolean
)
```

---

## üåê √âtape 3 : Cr√©er l‚Äôinterface de l‚ÄôAPI

```kotlin
import retrofit2.Call
import retrofit2.http.GET

interface ApiService {
    @GET("todos/1")
    fun getTodo(): Call<Todo>  // ‚ö†Ô∏è Pas suspend, pas de coroutine
}
```

---

## üîå √âtape 4 : Cr√©er l‚Äôobjet Retrofit

```kotlin
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

object RetrofitClient {
    val api: ApiService by lazy {
        Retrofit.Builder()
            .baseUrl("https://jsonplaceholder.typicode.com/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(ApiService::class.java)
    }
}
```

---

## üñºÔ∏è √âtape 5 : Cr√©er l‚ÄôUI avec Compose (et afficher la donn√©e)

```kotlin
package com.example.retrofitnoco

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.runtime.*
import androidx.compose.material.*
import androidx.compose.foundation.layout.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            TodoApp()
        }
    }
}

@Composable
fun TodoApp() {
    var titre by remember { mutableStateOf("Chargement...") }

    // ‚ö†Ô∏è On appelle Retrofit ici avec enqueue (asynchrone mais sans coroutine)
    LaunchedEffect(Unit) {
        val call = RetrofitClient.api.getTodo()
        call.enqueue(object : Callback<Todo> {
            override fun onResponse(call: Call<Todo>, response: Response<Todo>) {
                if (response.isSuccessful) {
                    val todo = response.body()
                    if (todo != null) {
                        titre = todo.title
                    } else {
                        titre = "R√©ponse vide"
                    }
                } else {
                    titre = "Erreur HTTP ${response.code()}"
                }
            }

            override fun onFailure(call: Call<Todo>, t: Throwable) {
                titre = "Erreur r√©seau : ${t.message}"
            }
        })
    }

    // UI simple
    Surface(modifier = Modifier.fillMaxSize()) {
        Column(
            modifier = Modifier.fillMaxSize().padding(24.dp),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(text = titre, style = MaterialTheme.typography.h5)
        }
    }
}
```

---

## üîç Explication p√©dagogique

| √âl√©ment | Explication |
|--------|-------------|
| `Call<Todo>` | Retrofit cr√©e une requ√™te asynchrone avec un callback |
| `enqueue(...)` | Ex√©cute la requ√™te en arri√®re-plan, et appelle `onResponse` ou `onFailure` |
| `LaunchedEffect(Unit)` | Permet d‚Äôex√©cuter du code une seule fois au d√©marrage (m√™me si ici, ce n‚Äôest pas une coroutine, √ßa reste pratique) |
| `titre` | Stocke le titre de la t√¢che et permet de l‚Äôafficher dynamiquement |

---

## ‚úÖ Avantages de cette m√©thode

- Facile √† comprendre pour les d√©butants
- Fonctionne **sans coroutines**
- Asynchrone gr√¢ce au **syst√®me de callback int√©gr√© √† Retrofit**

---

## ‚ö†Ô∏è Limites (raison pour passer aux coroutines ensuite)

| Limites | Pourquoi passer aux coroutines |
|---------|-------------------------------|
| Code plus verbeux | `enqueue(...)` = beaucoup de lignes |
| Moins lisible | Pas lin√©aire comme un `suspend fun` |
| Pas Compose-friendly | Les erreurs sont plus difficiles √† g√©rer proprement |
| Pas compatible avec `ViewModel` moderne | Les coroutines sont pr√©f√©r√©es dans l‚Äôarchitecture moderne (Jetpack) |

---

## üß† Conclusion

Tu sais maintenant utiliser Retrofit **sans coroutine**, de fa√ßon classique.  
C‚Äôest une √©tape importante pour bien comprendre le fonctionnement de base, avant de passer √† :

- ‚úÖ Retrofit + `suspend fun`  
- ‚úÖ ViewModel + `viewModelScope.launch`  
- ‚úÖ `StateFlow` ou `LiveData` pour g√©rer l‚Äô√©tat

---
