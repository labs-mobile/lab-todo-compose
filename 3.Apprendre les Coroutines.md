# ğŸ“š TUTORIEL â€” Apprendre les Coroutines avec un compteur automatique

---

## ğŸ”· Partie 1 : ğŸ“˜ ThÃ©orie

---

### ğŸ” ProblÃ©matique Ã  rÃ©soudre

Quand on dÃ©veloppe une application mobile, on veut souvent exÃ©cuter des tÃ¢ches **rÃ©guliÃ¨res ou lentes**, par exemple :

- IncrÃ©menter un compteur automatiquement
- Attendre un certain temps
- Charger des donnÃ©es depuis Internet
- Lire un fichier ou faire un calcul long

Mais si on **exÃ©cute Ã§a directement dans lâ€™interface utilisateur (UI)**, l'app devient **lente, figÃ©e, ou peut crasher**.

---

### ğŸ’¥ Mauvaise idÃ©e : bloquer le thread principal

En Android (et dans Compose), **lâ€™interface tourne sur un seul thread principal**, appelÃ© le **Main Thread**.

Si tu fais un `Thread.sleep()` dans lâ€™UI :
- Lâ€™Ã©cran **se bloque**
- Lâ€™utilisateur ne peut **rien faire**
- Android peut dire que lâ€™application ne rÃ©pond pas (**ANR** = Application Not Responding)

---

### âœ… Solution moderne : **les coroutines**

Les **coroutines** sont un systÃ¨me de Kotlin qui permet :

| Fonction | Explication |
|----------|-------------|
| `suspend` | Marquer une fonction qui peut Ãªtre suspendue (mise en pause) |
| `delay(ms)` | Suspend lâ€™exÃ©cution **sans bloquer lâ€™UI** |
| `launch {}` | DÃ©marre une **coroutine** : une tÃ¢che parallÃ¨le, lÃ©gÃ¨re |
| `LaunchedEffect` | DÃ©marre automatiquement une coroutine dans Compose |
| `rememberCoroutineScope()` | Pour lancer une coroutine depuis un bouton, etc. |

---

### ğŸ§  Pourquoi elles sont puissantes

- Plus **simples** que `Thread`, `Runnable`, `Timer`, etc.
- TrÃ¨s **lÃ©gÃ¨res** (des milliers de coroutines peuvent tourner)
- Ã‰crites comme du **code classique** (lisible, maintenable)
- 100% compatibles avec **Jetpack Compose**

---

## ğŸ”¶ Partie 2 : ğŸ§ª Tentative **sans coroutine** (le mauvais exemple)

---

### ğŸ”¥ ProblÃ¨me : crÃ©er un compteur qui sâ€™incrÃ©mente automatiquement

Tu pourrais penser Ã  faire comme ceci ğŸ‘‡

---

### ğŸ§± Code complet â€” **sans coroutine** :

```kotlin
package com.example.compteurbug

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.foundation.layout.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MauvaisCompteur()
        }
    }
}

@Composable
fun MauvaisCompteur() {
    var compteur by remember { mutableStateOf(0) }

    // âŒ Mauvaise pratique
    Thread {
        while (true) {
            Thread.sleep(1000)
            compteur++ // Cette ligne peut provoquer un crash !
        }
    }.start()

    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("Compteur : $compteur", style = MaterialTheme.typography.h5)
    }
}
```

---

### ğŸ’¥ Ce qui ne va pas

| ProblÃ¨me | DÃ©tail |
|----------|--------|
| ğŸ§Š UI bloquÃ©e | `Thread.sleep()` fige lâ€™interface |
| âš ï¸ AccÃ¨s dangereux | `compteur++` se fait depuis un autre thread que lâ€™UI |
| âŒ Compose pas compatible | Compose attend un environnement sÃ»r et contrÃ´lÃ© |

---

## ğŸŸ¢ Partie 3 : âœ… Solution propre avec coroutine

---

### âœ… Ce qu'on va faire :

- Remplacer `Thread.sleep()` par `delay()` â†’ non bloquant
- Lancer le code avec `LaunchedEffect` â†’ sÃ»r, automatique
- Garder l'UI **fluide et rÃ©active**

---

### ğŸ§± Code complet â€” **avec coroutine** :

```kotlin
package com.example.compteurcoroutine

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.delay

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            CompteurAvecCoroutine()
        }
    }
}

@Composable
fun CompteurAvecCoroutine() {
    var compteur by remember { mutableStateOf(0) }

    // âœ… Coroutine sÃ»re et fluide
    LaunchedEffect(Unit) {
        while (true) {
            delay(1000) // Attente non-bloquante
            compteur++  // Compose gÃ¨re la mise Ã  jour de l'UI
        }
    }

    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text("Compteur : $compteur", style = MaterialTheme.typography.h4)
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = { compteur = 0 }) {
            Text("RÃ©initialiser")
        }
    }
}
```

---

### âœ… RÃ©sultat :

| Effet | Explication |
|-------|-------------|
| â±ï¸ Le compteur sâ€™incrÃ©mente toutes les secondes | GrÃ¢ce Ã  `delay` dans une coroutine |
| ğŸ§  Lâ€™interface reste fluide | Aucun blocage du thread principal |
| ğŸ¯ Bonne pratique | 100% compatible avec Compose, lisible, sÃ»re |

---

## âœ… RÃ©sumÃ© pÃ©dagogique

| Sans coroutine âŒ | Avec coroutine âœ… |
|------------------|------------------|
| `Thread.sleep()` fige lâ€™app | `delay()` ne bloque rien |
| Risque de crash | SÃ©curisÃ© |
| Code lourd et pas Compose-friendly | Code moderne et clair |
| DifficultÃ© Ã  maintenir | Facile Ã  comprendre |

